# 复制模板

## 数学

```scala
def sumWithMod(s: Seq[Int], mod: Int): Int = {
  var sum = 0
  for (i <- s) sum = (sum + i) % mod
  sum
}

def factorial(n: Int): Long = {
  if (n == 0) return 1
  (1L to n).product
}

def factorialWithMod(n: Int, mod: Int): Int = {
  if (n == 0) return 1
  var product = 1L
  for (i <- 2 to n) product = (product * i) % mod
  product.toInt
}

def combination(m: Int, n: Int): Long = {
  if (m > n / 2) return combination(n - m, n)
  var res = 1L
  for (i <- 1 to m) {
    res *= n + 1 - i
    res /= i
  }
  res
}

def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)

def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)

def lcm(a: Long, b: Long): Long = a * b / gcd(a, b)

def gcd(arr: Array[Int]): Int = arr.reduce((res, next) => gcd(res, next))
```

## 二分查找

```scala
class BinarySearcher[T](value: Long => T)(implicit ord: Ordering[T]) {
  def this(arr: Array[T])(implicit ord: Ordering[T]) = {
    this(l => arr(l.toInt))(ord)
    defaultTo = arr.length
  }

  var defaultTo: Long = 1e9.toLong

  case class BinarySearchResult(index: Long, result: Option[T])

  def binarySearch(target: T, from: Long = 0L, to: Long = defaultTo,
                   findLeast: Boolean = false, findGreatest: Boolean = false,
                   less: Boolean = false, greater: Boolean = false): BinarySearchResult = {
    var l = from
    var r = to
    var res: BinarySearchResult = null
    while (l < r) {
      val mid = (l + r) / 2
      if (ord.lt(value(mid), target)) {
        l = mid + 1
        if (less) res = BinarySearchResult(mid, Some(value(mid)))
      } else if (ord.gt(value(mid), target)) {
        r = mid
        if (greater) res = BinarySearchResult(mid, Some(value(mid)))
      } else {
        res = BinarySearchResult(mid, Some(value(mid)))
        if (findLeast) r = mid
        else if (findGreatest) l = mid + 1
        else return res
      }
    }
    if (res == null) BinarySearchResult(l, None) else res
  }
}
```

## 动态规划

```scala
def dpOneDimension(n: Int, inits: List[(Int, Int)],
                   trans: (Array[Int], Int) => Int, from: Int = 1): Array[Int] = {
  val dp = new Array[Int](n + 1)
  for ((i, elem) <- inits) dp(i) = elem
  for (i <- from to n) dp(i) = trans(dp, i)
  dp
}

def dpTwoDimension(m: Int, n: Int, inits: List[(Int, Int, Int)],
                   optExec: Int => Array[Int],
                   trans: (Array[Array[Int]], Int, Int, Array[Int]) => Int,
                   from: Int = 1): Array[Array[Int]] = {
  val dp = Array.ofDim[Int](m + 1, n + 1)
  for ((i, j, elem) <- inits) dp(i)(j) = elem
  for (i <- from to m) {
    val optExecRes = optExec(i)
    for (j <- from to n) {
      dp(i)(j) = trans(dp, i, j, optExecRes)
    }
  }
  dp
}
```

## 记忆化

```scala
def cached(cache: scala.collection.mutable.HashMap[Int, Int], i: Int, generate: Int => Int): Int = {
  cache.getOrElseUpdate(i, generate(i))
}
```

## 双向 HashMap

```scala
class BidirectionalHashMap[K, V] {

  import scala.collection.mutable

  private val kv = new mutable.HashMap[K, V]
  private val vk = new mutable.HashMap[V, mutable.HashSet[K]]

  def containsKey(k: K): Boolean = kv.contains(k)

  def containsValue(v: V): Boolean = vk.contains(v)

  def valueSet: collection.Set[V] = vk.keySet

  def getValue(k: K): V = kv(k)

  def getValueOrElse(k: K, default: V): V = kv.getOrElse(k, default)

  def keySet: collection.Set[K] = kv.keySet

  def getKeys(v: V): mutable.HashSet[K] = vk(v)

  def put(k: K, v: V): Unit = {
    if (kv.contains(k)) {
      val oldV = kv(k)
      vk(oldV).remove(k)
      if (vk(oldV).isEmpty) vk.remove(oldV)
    }
    kv(k) = v
    if (!vk.contains(v)) vk(v) = new mutable.HashSet[K]
    vk(v) += k
  }

  def remove(k: K): Option[V] = {
    val optV = kv.remove(k)
    if (optV.nonEmpty) {
      val v = optV.get
      vk(v).remove(k)
      if (vk(v).isEmpty) vk.remove(v)
    }
    optV
  }
}
```

## 前缀和

```scala
class PreSumArray(arr: Array[Int], mod: Int = Int.MaxValue) {
  private val preSum = new Array[Long](arr.length + 1)

  for (i <- arr.indices) {
    preSum(i + 1) = preSum(i) + arr(i)
    if (mod < Int.MaxValue) preSum(i + 1) %= mod
  }

  def apply(from: Int, to: Int): Long = {
    val res = preSum(to) - preSum(from)
    if (mod == Int.MaxValue || res >= 0) res
    else res + mod
  }
}
```

## 单调栈

```scala
class MonotonicStack[T](min: Boolean = true, popSame: Boolean = true)
                       (implicit ord: Ordering[T]) {
  private val stack = new scala.collection.mutable.Stack[T]

  def push(elem: T, exec: T => Unit = _ => {}): Option[T] = {
    while (stack.nonEmpty &&
      ((!popSame && ord.equiv(elem, stack.head)) ||
        (min && ord.lt(elem, stack.head)) ||
        (!min && ord.gt(elem, stack.head)))
    ) {
      exec(stack.pop())
    }
    val res = stack.headOption
    stack.push(elem)
    res
  }

  def pop(): T = stack.pop()

  def head: T = stack.head

  def isEmpty: Boolean = stack.isEmpty

  def nonEmpty: Boolean = stack.nonEmpty

  def size: Int = stack.size
}
```

# 模板与题号

**最大公约数 gcd**：1201. 丑数 III（中等）

**最小公倍数 lcm**：1201. 丑数 III（中等）

**二分查找**：1201. 丑数 III（中等）、1751. 最多可以参加的会议数目 II

**二维 DP**：1751. 最多可以参加的会议数目 II

**记忆化**：1553. 吃掉 N 个橘子的最少天数

**双向 HashMap**: 1224. 最大相等频率

**单调栈**：1856. 子数组最小乘积的最大值

**前缀和**：1856. 子数组最小乘积的最大值